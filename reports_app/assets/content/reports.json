{
    "performance": {
        "title": "Performance",
        "content1": [
            {
                "title": "Static profiling",
                "content": [
                    {
                        "subtitle": "How did we do it?"
                    },
                    {
                        "text": "The static profiling tool used was Dart Analyzer. It is available on Visual Code Studio, included in either Flutter’s or Dart’s plugin. Having used this profiler for the project, we found that it’s very useful in alerting errors and warnings opportunely."
                    },
                    {
                        "subtitle": "Results"
                    },
                    {
                        "text": "Static profiling detected 94 problems spread across 17 files."
                    },
                    {
                        "image": "assets/images/performance/lint_2T2000S.jpg"
                    },
                    {
                        "text": "Several of these are more about style: “Avoid using braces in interpolation when not needed.”, referring to using '0${n}' instead of just '0$n'"
                    },
                    {
                        "image": "assets/images/performance/lint_2_2T2000S.jpg"
                    },
                    {
                        "image": "assets/images/performance/lint_3_2T2000S.png"
                    },
                    {
                        "text": "For example, explicitly declaring variables to null instead of letting Dart assume its null value:\n\n\t- ‘var a = null;’\n\ninstead of just\n\n\t- ’var a;’"
                    },
                    {
                        "text": "Also, declaring the type of variables in a class constructor when Dart can assume its type"
                    },
                    {
                        "text": "Other errors refer to good practices, namely “This class (or a class which this class inherits from) is marked as '@immutable', but one or more of its instance fields are not final: DayTitle.date”. This refers to having mutable variables (read: just regular variables without “final” or “const” keywords) in a StatelessWidget, which is inherently inmutable. In these cases, it’s better to mark the variables as inmutable with the “final” keyword. This doesn’t have real impact on the app execution."
                    },
                    {
                        "text": "Another error refers to accessing a protected variable from another class, violating the @protected tag. This is due to using outdated libraries; a function that was once public is now protected and deprecated in favor of another. Similarly, two classes that were implemented."
                    },
                    {
                        "text": "Other warnings do impact performance, or at the very least allocated memory. For example, unused variables, unused imports, unused libraries and unused classes. Also relating to imports, we found double imports in one file."
                    }
                ]
            },
            {
                "title": "Multithreading",
                "content": [
                    {
                        "subtitle": "Threading in this app"
                    },
                    {
                        "text": "This app has no actual multithreading, i.e., no isolates were used, and thus all the developed code runs in a single thread.\nOn the other hand, asynchronous calls are handled with simple placeholders, like using CircularProgressIndicators when there is no data available."
                    },
                    {
                        "image": "assets/images/performance/multithreading_2T2000S.jpg"
                    }
                ]
            },
            {
                "title": "CPU",
                "content": [
                    {
                        "subtitle": "How did we do it?"
                    },
                    {
                        "text": "We used an application made for profiling general performance on a mobile device (Simple System Monitor) and it helped us to measure CPU usage. The following tests were made on a Huawei Mate 10 Pro (6GB RAM, 8-core (4-2.32 Mhz, 4-1.86 Mhz) and 128 GB Storage), and every app was open on a sandbox environment with no other processes in background but main operating system."
                    },
                    {
                        "subtitle": "Tests"
                    },
                    {
                        "text": "Tests took about 500 seconds as profiling app allowed. This information provides average frequency used by each one of cores used during the test. Main features of the applications were used and we tried not to open external applications (e.g. Youtube, web browser, etc.)."
                    },
                    {
                        "subtitle": "Initial state"
                    },
                    {
                        "image": "assets/images/performance/cpu_usage_initial.jpg"
                    },
                    {
                        "subtitle": "Final state"
                    },
                    {
                        "image": "assets/images/performance/cpu_usage_2T2000S.jpg"
                    },
                    {
                        "subtitle": "Analysis"
                    },
                    {
                        "text": "Four of the cores are being used by native processes and only when we opened 2T2000S the other ones assisted. The average frequency of CPU usage were 1.45 GHz, which is about 250% more than initial state."
                    }
                ]
            },
            {
                "title": "Memory",
                "content": [
                    {
                        "subtitle": "How did we do it?"
                    },
                    {
                        "text": "Same as CPU analysis, we used Simple System Monitor app and it helped us to measure memory usage. The following tests were made on a Huawei Mate 10 Pro (6GB RAM, 8-core (4-2.32 Mhz, 4-1.86 Mhz) and 128 GB Storage), and every app was open on a sandbox environment with no other processes in background but main operating system features on Android."
                    },
                    {
                        "subtitle": "Tests"
                    },
                    {
                        "text": "Tests took about 500 seconds as profiling app allowed. This information shows average memory bytes used during the test. Main features of the applications were used and we tried not to open external applications (e.g. Youtube, web browser, etc.). It is important to know that exists an increasing values at the end of the test because of opening the app and taking the screenshot."
                    },
                    {
                        "subtitle": "Initial state"
                    },
                    {
                        "image": "assets/images/performance/memory_usage_initial.jpg"
                    },
                    {
                        "subtitle": "Final state"
                    },
                    {
                        "image": "assets/images/performance/memory_usage_2T2000S.jpg"
                    },
                    {
                        "subtitle": "Analysis"
                    },
                    {
                        "text": "Device tries to use the most bytes of memory as possible in order to provide proficient performance. 2T2000S app takes about 900 MB extra compared to initial state (sandbox empty environment)."
                    }
                ]
            },
            {
                "title": "Battery",
                "content": [
                    {
                        "subtitle": "Tests and strategy"
                    },
                    {
                        "text": "The test was to use the application for 15 minutes and observing the energy expenditure in the device (same device as CPU and memory section). The battery usage information was provided by operating system native features that measured spent energy by app."
                    },
                    {
                        "subtitle": "Energy consumption"
                    },
                    {
                        "image": "assets/images/performance/battery_usage_2T2000S.jpg"
                    },
                    {
                        "subtitle": "Analysis"
                    },
                    {
                        "text": "2T2000S did not use CPU on background unlike other apps (Facebook, Instagram, SpaceX-Go, ...). Also, the power consumption is 90 mAh (average) every 15 minutes in this device using common apps, and this application used 50.81 mAh (55% less)."
                    }
                ]
            }
        ],
        "content2": [
            {
                "title": "Static profiling",
                "content": [
                    {
                        "subtitle": "How did we do it?"
                    },
                    {
                        "text": "The static profiling tool used was Dart Analyzer. It is available on Visual Code Studio, included in either Flutter’s or Dart’s plugin. Having used this profiler for the project, we found that it’s very useful in alerting errors and warnings opportunely."
                    },
                    {
                        "subtitle": "Results"
                    },
                    {
                        "text": "Static profiling found no issues related to code. Only one issue was found, a left over TODO. It’s, funnily, written in Spanish and was left by a Spanish contributor. "
                    },
                    {
                        "image": "assets/images/performance/lint_1_spacex.png"
                    }
                ]
            },
            {
                "title": "Multithreading",
                "content": [
                    {
                        "subtitle": "Threading in this app"
                    },
                    {
                        "text": "This app uses no multithreading; no isolate instances are started."
                    }
                ]
            },
            {
                "title": "CPU",
                "content": [
                    {
                        "subtitle": "How did we do it?"
                    },
                    {
                        "text": "We used an application made for profiling general performance on a mobile device (Simple System Monitor) and it helped us to measure CPU usage. The following tests were made on a Huawei Mate 10 Pro (6GB RAM, 8-core (4-2.32 Mhz, 4-1.86 Mhz) and 128 GB Storage), and every app was open on a sandbox environment with no other processes in background but main operating system."
                    },
                    {
                        "subtitle": "Tests"
                    },
                    {
                        "text": "Tests took about 500 seconds as profiling app allowed. This information provides average frequency used by each one of cores used during the test. Main features of the applications were used and we tried not to open external applications (e.g. Youtube, web browser, etc.)."
                    },
                    {
                        "subtitle": "Initial state"
                    },
                    {
                        "image": "assets/images/performance/cpu_usage_initial.jpg"
                    },
                    {
                        "subtitle": "Final state"
                    },
                    {
                        "image": "assets/images/performance/cpu_usage_spacex.jpg"
                    },
                    {
                        "subtitle": "Analysis"
                    },
                    {
                        "text": "Four of the cores are being used by native processes and only when we opened SpaceX-Go the other ones assisted. The average frequency of CPU usage were 1.45 GHz, which is about 250% more than initial state."
                    }
                ]
            },
            {
                "title": "Memory",
                "content": [
                    {
                        "subtitle": "How did we do it?"
                    },
                    {
                        "text": "Same as CPU analysis, we used Simple System Monitor app and it helped us to measure memory usage. The following tests were made on a Huawei Mate 10 Pro (6GB RAM, 8-core (4-2.32 Mhz, 4-1.86 Mhz) and 128 GB Storage), and every app was open on a sandbox environment with no other processes in background but main operating system features on Android."
                    },
                    {
                        "subtitle": "Tests"
                    },
                    {
                        "text": "Tests took about 500 seconds as profiling app allowed. This information shows average memory bytes used during the test. Main features of the applications were used and we tried not to open external applications (e.g. Youtube, web browser, etc.). It is important to know that exists an increasing values at the end of the test because of opening the app and taking the screenshot."
                    },
                    {
                        "subtitle": "Initial state"
                    },
                    {
                        "image": "assets/images/performance/memory_usage_initial.jpg"
                    },
                    {
                        "subtitle": "Final state"
                    },
                    {
                        "image": "assets/images/performance/memory_usage_spacex.jpg"
                    },
                    {
                        "subtitle": "Analysis"
                    },
                    {
                        "text": "Device tries to use the most bytes of memory as possible in order to provide proficient performance. SpaceX-Go app takes about 1300 MB extra compared to initial state (sandbox empty environment)."
                    }
                ]
            },
            {
                "title": "Battery",
                "content": [
                    {
                        "subtitle": "Tests and strategy"
                    },
                    {
                        "text": "The test was to use the application for 15 minutes and observing the energy expenditure in the device (same device as CPU and memory section). The battery usage information was provided by operating system native features that measured spent energy by app."
                    },
                    {
                        "subtitle": "Energy consumption"
                    },
                    {
                        "image": "assets/images/performance/battery_usage_spacex.jpg"
                    },
                    {
                        "subtitle": "Analysis"
                    },
                    {
                        "text": "SpaceX-Go app did use CPU on background and consumed 11 mAh (20% higher) more than 2T2000S. This may be because SpaceX-GO makes a greater number of queries to obtain the information."
                    }
                ]
            }
        ],
        "color": "0xFF498467"
    },
    "storage": {
        "title": "Storage & Data Handling",
        "content1": [
            {
                "title": "Shared Preferences",
                "content": [
                    {
                        "text": "The only use of Shared Preferences is done by the cache manager. This is how the implementation of the Flutter Firebase Cache plugin works, but it will be included here since the library was implemented anew."
                    },
                    {
                        "text": "Everytime a cached file, in this case only photos and filters, is requested, the cache is updated in the CacheManager instance and also in Shared Preferences, in the form of a Json string."
                    },
                    {
                        "text": "Separately, the timestamp of the last update to the cache is also saved in Shared Preferences as an int (milliseconds since epoch)."
                    }
                ]
            },
            {
                "title": "Storage management",
                "content": [
                    {
                        "subtitle": "Local - Private"
                    },
                    {
                        "text": "This refers to storing data in SQLite. This app does not use this storage strategy."
                    },
                    {
                        "subtitle": "External - Public"
                    },
                    {
                        "text": "This refers to data stored inside the phone in an external folder, like the sd card.\nIn this case, data pictures taken by the user aren’t saved by default to the sd card, but the user can save his or any other picture after it has been successfully posted."
                    },
                    {
                        "text": "Opening an available picture yields the screen below (attention to the upper right corner)."
                    },
                    {
                        "image": "assets/images/storage/storage_1_2T2000S.png"
                    },
                    {
                        "text": "After hitting the save button on the upper right, a checked mark appears."
                    },
                    {
                        "image": "assets/images/storage/storage_2_2T2000S.png"
                    },
                    {
                        "text": "This, however, doesn’t actually save the image. If the user closes the Photo and opens it again, the save button appears again, as there is no logic behind showing or hiding the disquette icon in favour of a checked mark icon."
                    },
                    {
                        "subtitle": "Take a look at what this is doing to save the image:"
                    },
                    {
                        "image": "assets/images/storage/storage_3_2T2000S.png"
                    },
                    {
                        "text": "More on this method channel on the “code” report, since it has more to do with the way native code was implemented.\n\nLastly, external storage is also accessed when uploading a picture from the phone."
                    }
                ]
            },
            {
                "title": "Remote Storage",
                "content": [
                    {
                        "text": "Storage is largely managed with Firebase Storage, namely the schedule information, pictures and camera filters. Also, the app offers chatrooms, which are managed with Firebase Messaging."
                    }
                ]
            },
            {
                "title": "Cache & Data Fetching",
                "content": [
                    {
                        "text": "Cache is used to keep images in the app. Already loaded pictures are kept in the app for the user to see when they open the app. This avoids the need to fetch multimedia files from the server, and it’s a permanent cache."
                    },
                    {
                        "text": "Cache is also used to keep camera filters readily available too. When a filter is loaded, it is cached. It’s also a permanent cache."
                    },
                    {
                        "text": "To achieve this, the library flutter_cache_manager is used, and two files are implemented:\n- cached_firebase_image.dart\n- flutter_firebase_cache_manager\n\nIt’s unclear why these libraries are implemented by the developer."
                    },
                    {
                        "text": "The fetching strategy used is pull-based. Only when the user asks for cached data is it downloaded and kept within the app. When the user first tries to load a filter a spinner is shown, and on airplane mode, a spinner is shown forever."
                    },
                    {
                        "image": "assets/images/performance/noLoadedFilters(1).gif"
                    },
                    {
                        "text": "When the user has interacted with a filter it will show, but new ones won’t load still."
                    },
                    {
                        "image": "assets/images/performance/loadedFilters(1).gif"
                    }
                ]
            }
        ],
        "content2": [
            {
                "title": "Shared Preferences",
                "content": [
                    {
                        "text": "This app makes use of SharedPreferences in various instances, in four different files."
                    },
                    {
                        "subtitle": "app_model.dart"
                    },
                    {
                        "text": "In this file, a SharedPreferences instance is used in the init function to set or get a theme. If there is a theme, it loads it into the theme variable, and if there isn’t, it sets it anew to a default value of 1."
                    },
                    {
                        "image": "assets/images/storage/storage_4_spacex.PNG"
                    },
                    {
                        "subtitle": "spacex_home.dart"
                    },
                    {
                        "image": "assets/images/storage/storage_5_spacex.PNG"
                    },
                    {
                        "image": "assets/images/storage/storage_6_spacex.PNG"
                    },
                    {
                        "text": "This is used to set the notifications for the app. The date saved in the phone is validated to the next launchdate. This will update the scheduled notifications accordingly. See more on notifications on the ‘code’ report."
                    },
                    {
                        "subtitle": "settings.dart"
                    },
                    {
                        "text": "This sets the theme setting to another value depending on the current theme. This can be changed on the home tab."
                    },
                    {
                        "image": "assets/images/storage/storage_8_spacex.PNG"
                    },
                    {
                        "image": "assets/images/storage/storage_7_spacex.PNG"
                    },
                    {
                        "subtitle": "start.dart"
                    },
                    {
                        "text": "This use of SharedPreferences helps the developers know if the given user has donated to their Patreon. It will keep reappearing every 14 days if not."
                    },
                    {
                        "image": "assets/images/storage/storage_9_spacex.PNG"
                    }
                ]
            },
            {
                "title": "Storage management",
                "content": [
                    {
                        "subtitle": "Local - Private"
                    },
                    {
                        "text": "This refers to storing data in SQLite. This app does not use this storage strategy per se, but the cached_network_image library uses it to create the cache and keep the images in the app.",
                        "refs": "Cached_network_image::https://pub.dev/documentation/cached_network_image/latest/"
                    },
                    {
                        "subtitle": "External - Public"
                    },
                    {
                        "text": "This refers to storing data inside the phone in a public folder, like the sd_card for instance. This app does not use this storage strategy."
                    }
                ]
            },
            {
                "title": "Remote Storage",
                "content": [
                    {
                        "text": "Data is not saved remotely. However, data is fetched from two online services. The first one is used for the photos that can be found in the app."
                    },
                    {
                        "image": "assets/images/storage/storage_11_spacex.jpeg"
                    },
                    {
                        "image": "assets/images/storage/storage_10_spacex.PNG"
                    },
                    {
                        "text": "Aside from this, data about the launches and other information is fetched from the spacex API: https://api.spacexdata.com/v3/launches/upcoming. Information obtained from this API includes the upcoming launch dates, which vessel is set to be used and other relevant information. This is retrieved as a Json. The following is an excerpt:"
                    },
                    {
                        "image": "assets/images/storage/storage_12_spacex.PNG"
                    }
                ]
            },
            {
                "title": "Cache & Data Fetching",
                "content": [
                    {
                        "text": "Cache is used to keep images in the app. Already loaded pictures are kept in the app for the user to see when they open the app. This avoids the need to fetch multimedia files from the server, and it’s a permanent cache."
                    },
                    {
                        "text": "A library is declared, cached_network_image. This is used in the CachedImage widget."
                    },
                    {
                        "image": "assets/images/storage/storage_13_spacex.PNG"
                    },
                    {
                        "image": "assets/images/storage/storage_10_spacex.PNG"
                    },
                    {
                        "text": "This widget wraps the CachedNetworkImage widget that is provided by the library. This is a practice found in Flutter and React, where code that is commonly used with the same parameters is factorized. In this case, CachedNetworkImages always receive a different url, the same error function, and the same fade in duration. This CacheImage widget only has one parameter, the url, so it simplifies the code."
                    }
                ]
            }
        ],
        "color": "0xFF1B4079"
    },
    "rendering": {
        "title": "Rendering and Animations",
        "content1": [
            {
                "title": "UI",
                "content": [
                    {
                        "subtitle": "Do you like the look and feel of this app?"
                    },
                    {
                        "text": "All of the interviewed people liked this app, mostly because of the animations."
                    },
                    {
                        "subtitle": "Particularly, do you like the colors chosen for this app?"
                    },
                    {
                        "text": "Only three of interviewed people didn’t like the colors, particularly on the ‘Info’ view, saying it was rather hard on the eyes. One said it was too ‘Instagram-ish’, which is true."
                    },
                    {
                        "image": "assets/images/rendering/info1.jpeg"
                    },
                    {
                        "subtitle": "Was it hard to find your way through the interface?"
                    },
                    {
                        "text": "People generally found their way through the app without issues, however, it took them a couple seconds to find out that on the schedule view, each card contained buttons, and each element in the bottom sheet led to another window."
                    },
                    {
                        "image": "assets/images/rendering/ui1.jpeg"
                    },
                    {
                        "image": "assets/images/rendering/ui2.jpeg"
                    },
                    {
                        "image": "assets/images/rendering/ui3.jpeg"
                    },
                    {
                        "subtitle": "Further comments"
                    },
                    {
                        "text": "A couple people commented on how fun it was to take pictures and see them displayed after a couple seconds on the app."
                    },
                    {
                        "text": "One person commented on the camera button, saying it was ugly. Can’t say we disagree on that one."
                    },
                    {
                        "image": "assets/images/rendering/camera1.jpeg"
                    },
                    {
                        "text": "People generally liked how the app was always fluid."
                    },
                    {
                        "text": "One person commented that it would be cool to do a similar app as a roadmap for the induction days in Los Andes."
                    }
                ]
            },
            {
                "title": "Accessibility",
                "content": [
                    {
                        "text": "We ran Google’s Accessibility Scanner and found the following suggestions."
                    },
                    {
                        "subtitle": "We ran Google’s Accessibility Scanner and found the following suggestions."
                    },
                    {
                        "text": "Accessibility Scanner suggests an item label for all clickable items. In 2T2000s, several Widgets have no label, like the social media buttons in the Info tab."
                    },
                    {
                        "subtitle": "Color contrast"
                    },
                    {
                        "text": "Color contrast was an issue in two screens."
                    },
                    {
                        "subtitle": "Button size"
                    },
                    {
                        "text": "Button size was a warning on two screens."
                    }
                ]
            },
            {
                "title": "Rendering",
                "content": [
                    {
                        "text": "This section is rather short since we couldn’t profile the use of the GPU from within the app, however, there is one situation when the interface yanks."
                    },
                    {
                        "text": "It occurs when the user drags from the first card to the second, on the schedule view."
                    },
                    {
                        "image": "assets/images/rendering/rendering11.gif"
                    },
                    {
                        "text": "This can be fixed by switching to another physics handler. Currently, the app uses ScrollPhysics, a simple rename to AlwaysScrollableScrollPhysics would fix the issue. This scroll physics handler has no ‘deactivated’ timeframe when the user is unable to drag."
                    }
                ]
            },
            {
                "title": "What is animated?",
                "content": [
                    {
                        "text": "Several parts of the app use custom animations, and great part of the code is dedicated to animating the app. The most prominent and obvious custom animation is the one found on the home screen."
                    }
                ]
            },
            {
                "title": "Home Screen Animation",
                "content": [
                    {
                        "image": "assets/images/rendering/animation1.gif"
                    },
                    {
                        "text": "On the ‘Code’ report, the BLoC pattern used is described in more detail. However, one of the two blocs used is only to manage scroll information. The bloc is used to define a feed of the scroll state in the form of a few controllers, sinks (data flows to the bloc) and streams (data flows to the widget)."
                    },
                    {
                        "image": "assets/images/rendering/scrollbloc.png"
                    },
                    {
                        "text": "The state of the scroll is transformed eventually into a change in color and shape, which is what happens in the schedule view. To achieve this, several steps are made."
                    },
                    {
                        "text": "First, an AnimatedBackground class is defined. This receives a ‘t’ parameter, indicating the progress of the animation."
                    },
                    {
                        "text": "Second, the elements are defined. This includes an array of the background colors and the shapes, square, lines and triangles. In the example, two screens are shown, one with orange background with blue squares on top, and one with green background with six pink ‘lines’ on top."
                    },
                    {
                        "text": "Third, different functions are defined. They take the parameter ‘t’ and apply a transformation on the background color and the foreground shapes. There are four different functions, each defining how a screen will be animated. In this example, two of these functions are fired, interpolating between the two background colors, scaling and rotating from the middle of the screen and outwards."
                    },
                    {
                        "text": "Lastly, this animation implements its own Scrolling Physics, defined in ‘class MyScrollPhysics extends ScrollPhysics’. This overrides several methods, but the most interesting of them is the ‘carriedMomentum’ method. Defining a new formula for the momentum is what makes it possible to see this bouncy animation."
                    },
                    {
                        "image": "assets/images/rendering/animation31.gif"
                    },
                    {
                        "text": "All in all, this is very complex in its implementation and the fact that it’s all implemented in a single file with over 10 different classes makes it extremely hard to understand. This animation alone is comprised of over 800 lines of codes. It’s also something unlike anything we’ve seen on an App."
                    }
                ]
            },
            {
                "title": "Bottom Navigation Bar Animation",
                "content": [
                    {
                        "text": "This animation is more modest than the one in the home screen."
                    },
                    {
                        "image": "assets/images/rendering/animation2.gif"
                    },
                    {
                        "text": "It’s built with an AnimationController set on a duration of 300 milliseconds. An Animation is built using CurvedAnimation on a fastOutSlowIn fashion."
                    },
                    {
                        "image": "assets/images/rendering/apppage.png"
                    },
                    {
                        "text": "This animation is used on a FadeTransition that wraps each element in the BottomNavigationBar."
                    },
                    {
                        "image": "assets/images/rendering/fadetransition.png"
                    }
                ]
            }
        ],
        "content2": [
            {
                "title": "UI",
                "content": [
                    {
                        "text": "The following statement were result of guerrilla testing."
                    },
                    {
                        "subtitle": "Do you like the look and feel of this app?"
                    },
                    {
                        "text": "This app was well received by the 15 people interviewed. The clean interface design stood out among the interviewed people."
                    },
                    {
                        "subtitle": "Particularly, do you like the colors chosen for this app?"
                    },
                    {
                        "text":"Of the 15 people, 4 complained about the colors, saying it was too dark. This could be noise in the experiment since all of these 4 people that complained about it being too dark were interviewed during the day— a sunny day at that."
                    },
                    {
                        "text":"After being directed to the settings where they could choose their favourite theme, all users seemed to find a theme they were comfortable with, though most (10) people didn’t change it. Again, this could be due to having interviewed most people at night."
                    },
                    {
                        "subtitle": "Was it hard to find your way through the interface?"
                    },
                    {
                        "text":"People found their way through the app without any issue; the interface is very intuitive; tabs are easily understood, as are the buttons in the list view. They are all part of material’s metaphor."
                    },
                    {
                        "subtitle": "Further comments"
                    },
                    {
                        "text":"Two people noticed the subtle animations in the app and commented that they were fluid, simple and well done. One of them commented that they helped give the opening menu cohesion."
                    }
                ]
            },
            {
                "title": "Rendering",
                "content": [
                    {
                        "text": "Running a GPU profiling was possible, and no issues were found. It always renders in less than the recommended 16ms per frame in average. Also, no situation was found where a frame took more than 16ms to both render and display on screen. In the below image, a snapshot of the dynamic GPU and UI profiler is displayed."
                    }
                ]
            },
            {
                "title": "Animations",
                "content": [
                    {
                        "text": "There is only one animation in the home screen."
                    },
                    {
                        "image": "assets/images/rendering/rendering_4_spacex.gif"
                    },
                    {
                        "text": "This is handled in a very simple manner."
                    },
                    {
                        "image": "assets/images/rendering/rendering_1_spacex.png"
                    },
                    {
                        "image": "assets/images/rendering/rendering_3_spacex.png"
                    },
                    {
                        "text":"When building the home screen, the animation is declared and initialized in much the same manner as the home animation in the app 2T2000s. However, this app uses AnimatedWidget, which provides much of the actual animation elements. Besides creating the shown elements, there is not much more done to achieve this animation."
                    },
                    {
                        "image": "assets/images/rendering/rendering_2_spacex.png"
                    }
                ]
            }
        ],
        "color": "0xFFDA2C38"
    },
    "connectivity": {
        "title": "Connectivity",
        "content1": [
            {
                "title": "Connectivity Antipatterns",
                "content": [
                    {
                        "text": "The app loses content when it’s used without internet connection. The Lost Content issue is described as a situation when:\n\n- An app does not have connectivity\n-It shows empty, incomplete, or blurred content where it is supposed to be\n-The app does not report anything about a connectivity problem"
                    },
                    {
                        "text": "User Content type. It is lost when a picture is taken without internet, it isn’t saved anywhere so it can be sent afterwards, when there is internet. Blank Map type also happens. Lastly, Blank Image type happens as well."
                    }
                ]
            },
            {
                "title": "Scenario 1",
                "content": [
                    {
                        "text": "Install the app, turn on airplane mode and open the app. Try to interact with it."
                    },
                    {
                        "networkImage": "connectivity_1_2T2000S-min.gif"
                    },
                    {
                        "text": "2T2000S informs about no internet connection in schedule and main sections. However, map section is not providing information about it and let use its features normally."
                    }
                ]
            },
            {
                "title": "Scenario 2",
                "content": [
                    {
                        "text": "Interact with the app, exit, turn on airplane mode and open the app. Try to interact with it."
                    },
                    {
                        "networkImage": "connectivity_2_2T2000S-min.gif"
                    },
                    {
                        "text": "Application has similar behavior than Scenario 1, except for letting take photos and sending them in ‘time space’ section. These photos will never be sent and will no be able to view them on timeline."
                    }
                ]
            },
            {
                "title": "Scenario 3",
                "content": [
                    {
                        "text": "Interact with the app, but before using each feature, turn on airplane mode."
                    },
                    {
                        "networkImage": "connectivity_31_2T2000S-min.gif"
                    },
                    {
                        "networkImage": "connectivity_32_2T2000S-min.gif"
                    },
                    {
                        "text": "The only feature we could interrupt while it was being processed is the photo adding feature in timeline. This feature allows to pick overlays but when we disabled internet connection, the photo did not upload correctly. "
                    }
                ]
            },
            {
                "title": "Scenario 4",
                "content": [
                    {
                        "text": "Interact with the app, turning on airplane mode in the middle of executing each feature."
                    },
                    {
                        "networkImage": "connectivity_4_2T2000S-min.gif"
                    },
                    {
                        "text": "Most of sections tried to retrieved images and content for saving them in cache. When we disabled connection, many of them could still be shown."
                    }
                ]
            }
        ],
        "content2": [
            {
                "title": "Connectivity Antipatterns",
                "content": [
                    {
                        "text": "App reports that does not exist any launches but it is because of non-connectivity status of application. SpaceX couldnot retrieve data from servers and that is no related to the message that app shows."
                    },
                    {
                        "text": "The app loses content when it’s used without internet connection. The Lost Content issue is described as a situation when:\n\n- An app does not have connectivity\n-It shows empty, incomplete, or blurred content where it is supposed to be\n-The app does not report anything about a connectivity problem"
                    }
                ]
            },
            {
                "title": "Scenario 1",
                "content": [
                    {
                        "text": "Install the app, turn on airplane mode and open the app. Try to interact with it."
                    },
                    {
                        "networkImage": "connectivity_1_spacex-min.gif"
                    }
                ]
            },
            {
                "title": "Scenario 2",
                "content": [
                    {
                        "text": "Interact with the app, exit, turn on airplane mode and open the app. Try to interact with it."
                    },
                    {
                        "networkImage": "connectivity_2_spacex-min.gif"
                    }
                ]
            },
            {
                "title": "Scenario 3",
                "content": [
                    {
                        "text": "Interact with the app, but before using each feature, turn on airplane mode."
                    },
                    {
                        "networkImage": "connectivity_3_spacex-min.gif"
                    }
                ]
            },
            {
                "title": "Scenario 4",
                "content": [
                    {
                        "text": "Interact with the app, turning on airplane mode in the middle of executing each feature."
                    },
                    {
                        "networkImage": "connectivity_4_spacex-min.gif"
                    }
                ]
            }
        ],
        "color": "0xFFFFC145"
    },
    "code": {
        "title": "Code structure",
        "content1": [
            {
                "title": "Patterns",
                "content": [
                    {
                        "text": "This app implements the BLoC pattern. BLoC stands for Business Logic Component and is a pattern created and recommended by Google for Flutter."
                    },
                    {
                        "text": "This pattern is rather complicated to wrap your head around if it’s the first time you use Flutter. For us, it was easier to start with other options, like passing around Widget data from parent to child, and vice versa, before switching to using Scoped Models. There are several options to handling state, but BloC greatly reduces the complexity of listening to changes in the data."
                    },
                    {
                        "text": "BloC makes great use of reactive programming and the observer pattern by using the RxDart library, and streams of data by using the StreamBuilder widget, as well as Object Models."
                    },
                    {
                        "text": "The way this pattern is actually implemented isn’t clear, however. The pattern looks as follows."
                    },
                    {
                        "image": "assets/images/code/code_1_2T2000S.png"
                    },
                    {
                        "text": "The difference is that there is no repository in this project. It’s implemented as follows."
                    },
                    {
                        "image": "assets/images/code/code_2_2T2000S.png"
                    }
                ]
            },
            {
                "title": "Libraries",
                "content": [
                    {
                        "subtitle": "The following table shows version used and current version of libraries used by 2T2000S"
                    },
                    {
                        "image": "assets/images/code/code_3_2T2000S.png"
                    }
                ]
            },
            {
                "title": "Platform Specific Code",
                "content": [
                    {
                        "text": "The app runs platform specific code on one situation only. On either the map view or the event view, when the user taps on the map, the link opened is different for each platform. iOS directs to maps.apple.com and Android directs to Google Maps."
                    },
                    {
                        "image": "assets/images/code/code_4_2T2000S.png"
                    }
                ]
            },
            {
                "title": "Native Code",
                "content": [
                    {
                        "text": "The project makes two channels. Channels are the way that Flutter can communicate with native functions, that can be either already part of Android or iOS, or custom made. In this app, its the latter."
                    },
                    {
                        "text": "This app implements a channel to save an image to the phone and a channel to add the image filters. The first case sounds like an excellent candidate for a plugin, right? Well, a plugin has just been published a few days ago. On the overlay front, however, there is no option to actually combine two pictures into one, which is the case of the filters offered."
                    },
                    {
                        "subtitle": "This is what the filters look like"
                    },
                    {
                        "image": "assets/images/code/code_5_2T2000S.png"
                    }
                ]
            },
            {
                "title": "Native Android Code",
                "content": [
                    {
                        "subtitle": "A default MainActivity.java file in a Flutter app looks like this"
                    },
                    {
                        "image": "assets/images/code/code_6_2T2000S.png"
                    },
                    {
                        "subtitle": "And this is what MainActivity.java on this app looks like"
                    },
                    {
                        "image": "assets/images/code/code_7_2T2000S.png"
                    },
                    {
                        "text": "The two channels end up calling onMethodCall, so it has to handle them"
                    },
                    {
                        "image": "assets/images/code/code_8_2T2000S.png"
                    },
                    {
                        "text": "On the ‘addOverlayToImage’ call, things like phone orientation need to be handled to apply the overlay correctly, and the final image is comprised of a canvas with two Bitmaps drawn onto it."
                    },
                    {
                        "text": "On the ‘saveImage’ call, the image is never actually saved or written into a file, which is presumably why it doesn’t actually save the image."
                    }
                ]
            },
            {
                "title": "Native iOS Code",
                "content": [
                    {
                        "subtitle": "This was implemented in Objective-C on the AppDelegate.m file. A default AppDelegate.m file on Flutter looks like this"
                    },
                    {
                        "image": "assets/images/code/code_9_2T2000S.png"
                    },
                    {
                        "text": "On the app, a function was implemented in pretty much the same way it was in Java, but on Objective-C, with the exception that in iOS, the orientation isn’t handled directly as it is in Android, but comparing the height and width of the screen."
                    },
                    {
                        "image": "assets/images/code/code_10_2T2000S.png"
                    }
                ]
            },
            {
                "title": "Running Native Code",
                "content": [
                    {
                        "text": "After the desired channels have been defined, running native code from Flutter is simple. First, a MethodChannel must be declared and initialized. Method channel is part of the Flutter/services package for Dart."
                    },
                    {
                        "image": "assets/images/code/code_11_2T2000S.png"
                    },
                    {
                        "text": "It is used with invokeMethod, and Flutter will decide whether to invoke Android’s channel on MainActivity.java or iOS’ channel on AppDelegate.m."
                    },
                    {
                        "image": "assets/images/code/code_12_2T2000S.png"
                    }
                ]
            },
            {
                "title": "Programming Practices",
                "content": [
                    {
                        "subtitle": "Good programming practices"
                    },
                    {
                        "text": "BLoC architectural pattern. It’s described as a good practice that focuses on the principle of detaching UI and State and Data Handling, and it is applied according, mostly, to the guidelines available."
                    },
                    {
                        "text": "All images shown in the app are cached using the cached_network_image library."
                    },
                    {
                        "subtitle": "Bad programming practices"
                    },
                    {
                        "text": "A BLoC antipattern was encountered. Streams are opened but are never closed or otherwise disposed of. This is listed as an antipattern for BLoC, but it’s just generally a bad idea; it was also one of the points highlighted as a warning during the static code analysis, in the performance report."
                    },
                    {
                        "text": "Maintainability is an issue in this project. This was done by a single person, and given the ‘one use only’ nature of the project, one could argue that maintainability is not so much of an issue, however, this project became a referent for how powerful Flutter can be to build beautiful and smooth interfaces and animations."
                    },
                    {
                        "text": "Specifically, code could be heavily rearranged. The project comprises of a bloc folder containing two bloc models and one data provider, an (unused) models folder, an implementation of a library in the firebase_cache library (we couldn’t figure why it was implemented, it’s just the regular library files), 12 loose UI files and 1 utils file."
                    },
                    {
                        "text": "Each of the UI files contains several (up to 25) classes. Granted, all of them belong to the same view, but a general good practice is to, when possible, limit a .dart file to one class, when it’s a StatelessWidget, or two, when it’s a StatefulWidget."
                    }
                ]
            }
        ],
        "content2": [
            {
                "title": "Patterns",
                "content": [
                    {
                        "text": "This app implements Scoped Model. It’s one of the ways to architect a Flutter application. Currently there are 3 major/popular ways to architect the way data is passed around the widgets.",
                        "refs": "Flutter architecture::https://medium.com/flutter-community/flutter-app-architecture-101-vanilla-scoped-model-bloc-7eff7b2baf7e"
                    },
                    {
                        "text": "This library has been described as a “set of utilities that allow you to easily pass a data Model from a parent Widget down to its descendants. In addition, it also rebuilds all of the children that use the model when the model is updated. This library was originally extracted from the Fuchsia codebase.”",
                        "refs": "Fuchsia and Flutter::https://medium.com/jay-tillu/fuchsia-os-the-game-changer-in-os-world-bf8f1f6d25e8"
                    },
                    {
                        "text": "So ScopedModel is a way to centralize data and state management, instead of the default ‘setState’ call, that works much like React in that it handles a StatefulWidget’s state and repaints the widget. With a ScopedModel you can have files with the data handling you need, and call them with the ScopedModelDescendant widget."
                    },
                    {
                        "text": "The ScopedModelDescendant widget works as an observer, and the given model—the observable— can notify them and cause them to repaint."
                    },
                    {
                        "subtitle": "This is a ScopedModelDescendant that listens to changes in the AppModel."
                    },
                    {
                        "image": "assets/images/code/code_1_spacex.PNG"
                    },
                    {
                        "text": "A ScopedModelDescendant includes must be initialized with a builder parameter. It takes a function that returns the actual widget that will be displayed. In the image above we can also see a ScopedModel widget."
                    },
                    {
                        "text": "This widget must wrap the entire widget tree that uses this model, in this case the MaterialApp, and it takes a model parameter with the only instance of the model in the whole app. The model parameter is only initialized once for the entire application."
                    },
                    {
                        "image": "assets/images/code/code_2_spacex.PNG"
                    },
                    {
                        "text": "The AppModel must extend Model, from the ScopedModel library."
                    },
                    {
                        "image": "assets/images/code/code_3_spacex.PNG"
                    },
                    {
                        "text": "And the way the model notifies its listeners when a change has been done in the data is with the following line."
                    },
                    {
                        "image": "assets/images/code/code_4_spacex.PNG"
                    },
                    {
                        "text": "This app defines different models, each updates and notifies a different piece of code. It’s actually very well organized. Here’s a model that shows the structure that the developers built."
                    },
                    {
                        "image": "assets/images/code/code_5_spacex.png"
                    }
                ]
            },
            {
                "title": "Libraries",
                "content": [
                    {
                        "subtitle": "Libraries declared"
                    },
                    {
                        "image": "assets/images/code/spacecx-libraries.png"
                    }
                ]
            },
            {
                "title": "Platform Specific Code",
                "content": [
                    {
                        "text": "In this app, platform specific code is not explicitly declared. However, a library used, Flutter Web Browser, has a specific parameter for Android for the toolbar color. Each time the browser is called, this parameter is set to the theme’s primary color."
                    },
                    {
                        "image": "assets/images/code/code_6_spacex.PNG"
                    },
                    {
                        "text": "Another library also runs platform specifics, Flutter Local Notifications, takes in two different parameters, one for Android and one for iOS. These parameters are also part of the same library."
                    },
                    {
                        "image": "assets/images/code/code_7_spacex.PNG"
                    },
                    {
                        "text": "Despite this, there is not much real platform specific development done."
                    }
                ]
            },
            {
                "title": "Native code",
                "content": [
                    {
                        "text": "There is no native code developed, and no channels declared or used."
                    }
                ]
            },
            {
                "title": "Programming Practices",
                "content": [
                    {
                        "subtitle": "Good practices"
                    },
                    {
                        "text": "Architecture in this project is very simple and easy to understand. As shown earlier, each widget that needs its state handled, has an associated model. Models that have common methods extend a ‘base’ model, QueryModel, with methods like setLoading, which updates the loading spinners everywhere in the app."
                    },
                    {
                        "text": "Something to highlight is that the widgets are set to listen only to the relevant model for changes. For our project, all widgets were set to listen to a single model."
                    },
                    {
                        "text": "Also, apart from this, data objects are defined for concepts like vehicles, missions and rockets. This was outside the scope of the diagram shown earlier though."
                    },
                    {
                        "subtitle": "Bad practices"
                    },
                    {
                        "text": "We actually found this project to be very thought through, organized, clean and we didn’t see bad programming practices."
                    },
                    {
                        "text": "Also, we could suggest not to mix ScopedModels with the actual data models. Having two folders would be a good idea."
                    }
                ]
            }
        ],
        "color": "0xFF4B2142"
    }
}